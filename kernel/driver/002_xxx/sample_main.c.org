/*-----------------------------------------------------------------------------
  file : vocoder_main.c
  desc : 
  auth : freefrug@falinux.com
  date : 2016-07 ~
  noty : linux 3.14 for imx6

-------------------------------------------------------------------------------*/
#ifndef __KERNEL__
#define __KERNEL__
#endif

#ifndef MODULE
#define MODULE
#endif

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/sched.h> 
#include <linux/interrupt.h>
#include <linux/wait.h>
#include <linux/slab.h>    
#include <linux/poll.h>     
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/workqueue.h>
#include <linux/irq.h>		
#include <linux/time.h>			
#include <linux/timer.h>		
#include <linux/platform_device.h>
#include <linux/dma-mapping.h>
#include <asm/uaccess.h>
#include <asm/ioctl.h>
#include <asm/unistd.h>
#include <asm/io.h>
#include <asm/irq.h>

#include "vocoder.h"

#define		THIS_DRV_VER		"0.0.1"
#define		THIS_DRV_NAME		DRIVER_NAME_VOCODER
#define		THIS_DRV_MAJOR		DRIVER_MAJOR_VOCODER

#define		THIS_PROC_DIR_TOP	PROC_DIR_APSI
#define		THIS_PROC_DIR		PROC_DIR_VOCODER

/* global var -----------------------------------------------------------------*/
int showmsg = 1;


/* local var ------------------------------------------------------------------*/
static int major   = DRIVER_MAJOR_VOCODER;


typedef struct 
{
	struct work_struct  workq;  		// 
	struct delayed_work delay_workq;  	//
	wait_queue_head_t	waitq;			// 
	struct timer_list	timer;			//
	struct completion   completion;  
	
} private_struct_t;

/*
	init_waitqueue_head( &pv->waitq );					// 처음 한번 초기화
	interruptible_sleep_on_timeout( &pv->waitq, HZ );	// 이벤트 대기
	wake_up_interruptible( &pv->waitq );				// 이벤트 발생

	init_completion( &pv->completion );					// wait_for_completion() 함수 호출하기 전에 항상 초기화
	wait_for_completion( &pv->completion );				// 이벤트 대기
	complete( &pv->completion );						// 이벤트 발생
	
	INIT_WORK( &pv->workq, std_workq_handle );			// 처음 한번 초기화
	schedule_work( &pv->workq );

	INIT_DELAYED_WORK( &pv->delay_workq, std_workq_handle );
	schedule_delayed_work( &pv->delay_workq );

*/

/* implementaion ==============================================================*/

//------------------------------------------------------------------------------
/** @brief   workq callback function
	@remark  
*///----------------------------------------------------------------------------
static void  voc_workq_handle( struct work_struct *_work) 
{
	//private_struct_t  *pv = container_of(_work, private_struct_t, workq);

	printk( "workq handle\n" );
}
//------------------------------------------------------------------------------
/** @brief   timer handler
	@remark  
*///----------------------------------------------------------------------------
static void voc_timer_handler( unsigned long data )
{
	private_struct_t *pv = (private_struct_t *)data;
	
	pv->timer.expires  = get_jiffies_64() + (HZ);
	add_timer( &pv->timer );
	
	printk( "timer event\n" );
}
//------------------------------------------------------------------------------
/** @brief   interrupt handler
	@remark  
///----------------------------------------------------------------------------
static irqreturn_t	voc_interrupt( int irq, void *dev_id )
{
	return IRQ_HANDLED;	
}*/
//------------------------------------------------------------------------------
/** @brief   fops.open
	@remark  
*///----------------------------------------------------------------------------
static int voc_open( struct inode *inode, struct file *filp )
{	
	private_struct_t *pv;
	//unsigned int minor = MINOR(inode->i_rdev);

	if (0)
	{
		pv = (private_struct_t *)kmalloc( sizeof(private_struct_t), GFP_KERNEL );
		filp->private_data = pv;
		
		// 워크큐 초기화
		INIT_WORK( &pv->workq, voc_workq_handle );
		
		// 웨이트 큐 초기화
		init_waitqueue_head( &pv->waitq );

		init_timer( &pv->timer );
		pv->timer.expires  = get_jiffies_64() + (HZ);
		pv->timer.function = voc_timer_handler;
		pv->timer.data     = (unsigned long)pv;
		add_timer( &pv->timer );
	}

	try_module_get( THIS_MODULE );
    DBG_MSG(" %s OPEN\n", THIS_DRV_NAME );
    return 0;
}
//------------------------------------------------------------------------------
/** @brief   fops.release
	@remark  
*///----------------------------------------------------------------------------
static int voc_release( struct inode *inode, struct file *filp)
{
	private_struct_t *pv;
	
	if (0)
	{
		pv = (private_struct_t *)filp->private_data;
	
		if ( pv )
		{
			flush_scheduled_work();  // 워크큐 소모
			
			kfree( pv );
			filp->private_data = NULL;
		}
	}

    module_put( THIS_MODULE );
    DBG_MSG(" %s CLOSE\n", THIS_DRV_NAME );
    return 0;
}
//------------------------------------------------------------------------------
/** @brief   fops.read
	@remark  
*///----------------------------------------------------------------------------
static ssize_t voc_read (struct file *filp, __user char *ubuf, size_t count, loff_t *ppos)
{
	private_struct_t *pv;
	
	if (0)
	{
		pv = (private_struct_t *)filp->private_data;
	}
	
	return 0;
}
//------------------------------------------------------------------------------
/** @brief   fops.write
	@remark  
*///----------------------------------------------------------------------------
static ssize_t voc_write(struct file *filp, const __user char *ubuf, size_t count, loff_t *ppos )
{
	return 0;
}
//------------------------------------------------------------------------------
/** @brief   fops.unlock_ioctl
	@remark  
*///----------------------------------------------------------------------------
static long voc_ioctl( struct file *filp, unsigned int cmd, unsigned long arg )
{
    switch( cmd )
    {
	case IOCTL_BURST_READ  :
		//if ( copy_from_user( (void *)&bda, (void *)arg, sizeof(burst_data_t) ) ) 
		//	return -EFAULT;
		return 0;

	case IOCTL_BURST_WRITE :
		//if ( copy_from_user( (void *)&bda, (void *)arg, sizeof(burst_data_t) ) )
		//	return -EFAULT;
		return 0; 
    }
       
	return -EINVAL;
}
//------------------------------------------------------------------------------
/** @brief   fops.poll
	@remark  
*///----------------------------------------------------------------------------
static unsigned int voc_poll(struct file *filp, struct poll_table_struct *wait )
//static unsigned int voc_poll(struct file *filp, poll_table *wait )
{
	unsigned int mask = 0;
	//poll_wait( filp, &voc_waitq, wait);
	//if ( dat_push != dat_pop ) mask |= POLLIN | POLLRDNORM;
	return mask;
}
//------------------------------------------------------------------------------
/** @brief   proc.read
	@remark  
*///----------------------------------------------------------------------------
static int voc_proc_show( struct seq_file *m, void *v )
{
	long tag = (long)m->private;
	
	switch( tag )
	{
	default :
		seq_printf( m, "\n%s ver %s\n", THIS_DRV_NAME, THIS_DRV_VER );
		seq_printf( m, "===========================\n");
		seq_printf( m, " showmsg      %d\n", showmsg  );
		
		seq_printf( m, "\n");
	}
	return 0;
}
//------------------------------------------------------------------------------
/** @brief   proc.write
	@remark  
*///----------------------------------------------------------------------------
static ssize_t voc_proc_write( struct file *file, const char *buf, size_t count, loff_t *pos )
{
        long tag = (long)(PDE_DATA(file_inode(file)));
        char *cmd, lbuf[128];

        if (count >= sizeof(lbuf)) count = sizeof(lbuf)-1;

        if (copy_from_user( lbuf, buf, count))
                return -EFAULT;
        lbuf[count] = 0;
        cmd = lbuf;

        switch (tag)
        {
        default : 
			if ( strncmp( "showmsg=", cmd, 8 ) == 0 ) 
			{   
				showmsg = simple_strtoul( cmd+8, NULL, 0 );
			}
			break;
        }
        
        return count;
}
//------------------------------------------------------------------------------
/** @brief   proc.open
	@remark  
*///----------------------------------------------------------------------------
static int voc_proc_open( struct inode *inode, struct file *file )
{
	return single_open( file, voc_proc_show, PDE_DATA(inode) );
}
//------------------------------------------------------------------------------
/** @brief   create proc
	@remark  
*///----------------------------------------------------------------------------
static struct proc_dir_entry *proc_dir_top = NULL;
static struct proc_dir_entry *proc_dir = NULL;
static const struct file_operations voc_proc_fops = {
	.owner          = THIS_MODULE,
	.read           = seq_read,
	.llseek         = seq_lseek,
	.release        = single_release,
	.open           = voc_proc_open,
	.write          = voc_proc_write,
};
static void voc_create_procfs( void )
{
	proc_dir_top = proc_mkdir( THIS_PROC_DIR_TOP, 0            );
	proc_dir     = proc_mkdir( THIS_PROC_DIR    , proc_dir_top );
		
	proc_create_data( "info", S_IRUGO|S_IWUSR, proc_dir, &voc_proc_fops, (void *)0 );	
	proc_create_data( "ctrl", S_IRUGO|S_IWUSR, proc_dir, &voc_proc_fops, (void *)1 );	
}	

//------------------------------------------------------------------------------
/** @brief   free proc
	@remark  
*///----------------------------------------------------------------------------
static void voc_free_procfs( void )
{
	if (proc_dir    ) proc_remove( proc_dir     );
	if (proc_dir_top) proc_remove( proc_dir_top );
}

//------------------------------------------------------------------------------
/** @brief   define struct for file_operations
*///----------------------------------------------------------------------------
static struct file_operations voc_fops =
{
        .open    = voc_open, 
        .release = voc_release, 
        .read    = voc_read,
        .write   = voc_write,
        .poll    = voc_poll,
		.unlocked_ioctl = voc_ioctl,
};
//------------------------------------------------------------------------------
/** @brief   device release
	@remark  
*///----------------------------------------------------------------------------
static void voc_device_release( struct device *dev )
{
	DBG_MSG(" %s device release\n", THIS_DRV_NAME );
}

//------------------------------------------------------------------------------
/** @brief   device probe
	@remark  
*///----------------------------------------------------------------------------
static int voc_probe( struct platform_device *pdev )
{
	struct device *dev = &pdev->dev;
	
	dev->release = voc_device_release;
	
    major &= 0xff;
    if( !register_chrdev( major, THIS_DRV_NAME, &voc_fops ) )  
    {
        printk(" register device %s ver %s OK (major=%d)\n", THIS_DRV_NAME, THIS_DRV_VER, major );
    }        
    else
    {        
        printk(" unable to get major %d for %s \n", major, THIS_DRV_NAME );
        return -EBUSY;
    }

	voc_create_procfs(); 
	
    return 0;		
}
//------------------------------------------------------------------------------
/** @brief   device remove
	@remark  
*///----------------------------------------------------------------------------
static int voc_remove( struct platform_device *pdev )
{
	//struct device *dev = &pdev->dev;

    unregister_chrdev( major, THIS_DRV_NAME );
    
    voc_free_procfs();
    
    printk(" unregister %s OK\n", THIS_DRV_NAME );
    
    return 0;
}
//------------------------------------------------------------------------------
/** @brief   platform resource
*///----------------------------------------------------------------------------
static struct resource voc_resources[] = {
	[0] = {
		.start  = 0,
		.end    = 0  + 0xff, 
		.flags  = IORESOURCE_MEM,
	},  
};
struct platform_device voc_device = {
	.name           = THIS_DRV_NAME,
	.id     		= -1,
	.num_resources  = ARRAY_SIZE(voc_resources),
	.resource       = voc_resources,
	.dev		= {
		.platform_data = NULL,
	}
};
static struct platform_driver voc_driver = {
	.probe  = voc_probe,
	.remove = voc_remove,
	.driver = {
		.name  = THIS_DRV_NAME,
		.owner = THIS_MODULE,
	},
};

//------------------------------------------------------------------------------
/** @brief   driver init
	@remark  
*///----------------------------------------------------------------------------
static int __init voc_init(void)
{
	platform_device_register( &voc_device );
	
	return platform_driver_register( &voc_driver );
}
//------------------------------------------------------------------------------
/** @brief   driver exit
	@remark  
*///----------------------------------------------------------------------------
static void __exit voc_exit(void)
{
	platform_driver_unregister( &voc_driver );

	platform_device_unregister( &voc_device );
}

/*-----------------------------------------------------------------------------*/

module_init(voc_init);
module_exit(voc_exit);

module_param(major, int, 0);
module_param(showmsg, int, 0);

MODULE_AUTHOR("freefrug@falinux.com");
MODULE_LICENSE("GPL");

/* end */
